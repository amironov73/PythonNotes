### Магические методы

Магические методы позволяют задать поведение экземпляров ваших классов в определенных ситуациях.

#### Конструирование и удаление объектов

* **\_\_init\_\_ (self, ...)** - наверное, самый известный магический метод. Он вызывается при создании экземпляра объекта.

* **\_\_new\_\_ (cls, ...)** - предшественник `__new__`. Именно он конструирует новый экземпляр объекта, который затем в виде `self` попадает в `__init__`. Обратите внимание, это метод класса, а не экземпляра!

* **\_\_del\_\_ (self)** - деструктор, ответственный за уничтожение экземпляра объекта.

Пример совместной работы `__init__` и `__del__`:

```python
from os.path import join

class FileObject:

    def __init__(self, filepath='~', filename='sample.txt'):
        self.file = open(join(filepath, filename), 'r+')

    def __del__(self):
        self.file.close()
        del self.file
```

#### Сравнение объектов

* **\_\_cmp\_\_ (self, other)** - самый базовый из методов сравнения. **В Python 3 больше нет!**

* **\_\_eq\_\_ (self, other)** - оператор `==`.

* **\_\_ne\_\_ (self, other)** - оператор `!=`.

* **\_\_lt\_\_ (self, other)** - оператор `<`.

* **\_\_gt\_\_ (self, other)** - оператор `>`.

* **\_\_le\_\_ (self, other)** - оператор `<=`.

* **\_\_ge\_\_ (self, other)** - оператор `>=`.

```python
class Word(str):
    """Класс для слов, определяющий сравнение по длине слов."""

    def __new__(cls, word):
        # Мы должны использовать __new__, так как тип str неизменяемый
        # и мы должны инициализировать его раньше (при создании)
        if ' ' in word:
            print("Value contains spaces. Truncating to first space.")
            word = word[:word.index(' ')] # Теперь Word это все символы до первого пробела
        return str.__new__(cls, word)

    def __gt__(self, other):
        return len(self) > len(other)
    def __lt__(self, other):
        return len(self) < len(other)
    def __ge__(self, other):
        return len(self) >= len(other)
    def __le__(self, other):
        return len(self) <= len(other)
```

#### Числовые магические методы

Унарные операторы

* **\_\_pos\_\_ (self)** - унарный плюс `+some_object`.

* **\_\_neg\_\_ (self)** - отрицание `-some_object`.

* **\_\_abs\_\_ (self)** - для функции `abs()`.

* **\_\_invert\_\_ (self)** - инвертирование `~`.

* **\_\_round\_\_ (self)** - для функции `round()`.

* **\_\_floor\_\_ (self)** - для функции `math.floor()`.

* **\_\_ceil\_\_ (self)** - для функции `math.ceil()`.

* **\_\_trunc\_\_ (self)** - для функции `math.trunc()`.

Обычные арифметические операторы

* **\_\_add\_\_ (self, other)** - сложение `a + b`.

* **\_\_sub\_\_ (self, other)** - вычитание `a - b`.

* **\_\_mul\_\_ (self, other)** - умножение `a * b`.

* **\_\_floordiv\_\_ (self, other)** - целочисленное деление `a // b`.

* **\_\_div\_\_ (self, other)** - деление `a / b`. **В Python 3 больше нет, т. к. деление по умолчанию правильное (см. ниже)!**

* **\_\_truediv\_\_ (self, other)** - правильное деление. Работает после `from __future__ import division`.

* **\_\_mod\_\_ (self, other)** - деление по модулю `a % b`.

* **\_\_divmod\_\_ (self, other)** - для функции `divmod()`.

* **\_\_pow\_\_ (self, other)** - возведение в степень `a ** b`.

* **\_\_lshift\_\_ (self, other)** - сдвиг влево `a << b`.

* **\_\_rshift\_\_ (self, other)** - сдвиг вправо `a >> b`.

* **\_\_and\_\_ (self, other)** - двоичное И `a & b`.

* **\_\_or\_\_ (self, other)** - двоичное ИЛИ `a | b`.

* **\_\_xor\_\_ (self, other)** - исключающее ИЛИ `a ^ b`.

Отраженные операторы

* **\_\_radd\_\_ (self, other)** - отраженное сложение.

* **\_\_rsub\_\_ (self, other)** - отраженное вычитание.

* **\_\_rmul\_\_ (self, other)** - отраженное умножение.

* **\_\_rfloordiv\_\_ (self, other)** - отраженное целочисленное деление.

* **\_\_rdiv\_\_ (self, other)** - отраженное деление.

* **\_\_rtruediv\_\_ (self, other)** - отраженное правильное деление.

* **\_\_rmod\_\_ (self, other)** - отраженное деление по модулю.

* **\_\_rdivmod\_\_ (self, other)** - для отраженной функции `divmod()`.

* **\_\_rpow\_\_ (self, other)** - отраженное возведение в степень.

* **\_\_rlshift\_\_ (self, other)** - отраженный сдвиг влево.

* **\_\_rrshift\_\_ (self, other)** - отраженный сдвиг вправо.

* **\_\_rand\_\_ (self, other)** - отраженное двоичное И.

* **\_\_ror\_\_ (self, other)** - отраженное двоичное ИЛИ.

* **\_\_rxor\_\_ (self, other)** - отраженное исключающее ИЛИ.

Составное присваивание

* **\_\_iadd (self, other)\_\_** - сложение с присваиванием `a += b`.

* **\_\_isub (self, other)\_\_** - вычитание с присваиванием `a -= b`.

* **\_\_imul (self, other)\_\_** - умножение с присваиванием `a *= b`.

* **\_\_ifloordiv (self, other)\_\_** - целочисленное деление с присваиванием `a //= b`.

* **\_\_idiv (self, other)\_\_** - деление с присваиванием `a += b`.

* **\_\_itruediv (self, other)\_\_** - правильное деление с присваиванием `a /= b`.

* **\_\_imod (self, other)\_\_** - деление по модулю с присваиванием `a ^= b`.

* **\_\_ipow (self, other)\_\_** - возведение в степень с присваиванием `a **= b`.

* **\_\_ilshift (self, other)\_\_** - сдвиг влево с присваиванием `a <<= b`.

* **\_\_irshift (self, other)\_\_** - сдвиг вправо с присваиванием `a >>= b`.

* **\_\_iand (self, other)\_\_** - логическое И с присваиванием `a &= b`.

* **\_\_ior (self, other)\_\_** - логическое ИЛИ с присваиванием `a |= b`.

* **\_\_ixor (self, other)\_\_** - исключающее ИЛИ с присваиванием `a ^= b`.

#### Преобразование типов

* **\_\_int(self)\_\_** - преобразование в `int`.

* **\_\_long(self)\_\_** - преобразование в `long`.

* **\_\_float(self)\_\_** - преобразование в `float`.

* **\_\_complex(self)\_\_** - преобразование в `complex`.

* **\_\_oct(self)\_\_** - преобразование в восмеричное число.

* **\_\_hex(self)\_\_** - преобразование в шестнадцатиричное число.

* **\_\_index(self)\_\_** - преобразование в `int`, когда объект используется в срезах `[start:stop:step]`.

* **\_\_trunc(self)\_\_** - для функции `math.trunc()`.

* **\_\_coerce(self)\_\_** - метод для реализации арифметики с операндами разных типов. `__coerce__` должен вернуть None если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из `self` и `other`, преобразованных к одному типу. **В Python 3 больше нет!**

#### Строковое представление

* **\_\_str\_\_(self)** - для функции `str()`.

* **\_\_repr\_\_(self)** - для функции `repr()`. Желательно возвращать валидный код на Python.

* **\_\_unicode\_\_(self)** - для функции `unicode()`. **В Python 3 больше нет! (зато см. ниже)**

* **\_\_bytes(self)\_\_** - В Python 3 выдает представление в однобайтовой кодировке.

* **\_\_format\_\_(self, formatstr)** - для функции `format()`

#### Прочее

* **\_\_hash\_\_(self)** - для функции `hash()`.

* **\_\_bool\_\_(self)** - для функции `bool()`.
 
 
