### Строки

#### Литералы

Строковые литералы в Python бывают следующие:

* Заключенные в 'одинарные' и "двойные кавычки" без префиксов. Кроме собственно кавычек, различий между ними нет. В них работает экранирование символов (см. ниже).
* Многострочные литералы, ограниченные троекратными кавычками (как одинарынми, так и двойными):

```python
"""Hello
world!"""
```

Это эквивалентно `'Hello\nworld!`. Экранирование символов в таких литералах работает. 

Такие литералы отлично подходят для docstring (см. ниже) в классах или функциях.

* Снабженные префиксом `r` или `R` (кавычки могут быть любыми, в т. ч. троекратными). В них экранирование не работает.
* Снабженные префиксом `u` или `U` (кавычки могут быть любыми). В Python 3 ничем не отличаются от таких же без префикса. В Python 2 они означали Unicode-строки. Экранирование работает.
* Снабженные префиксом `b` или `B` (кавычки могут быть любыми). Они означают строку в однобайтной кодировке, принятой в системе по умолчанию. Проще говоря, это массив байт. Экранирование работает. Прикол:

```python
print('Hello' == b'Hello')
# False
```

* Снабженные префиксом `f` или `F` (кавычки могут быть любыми). Это строки инлайн-форматированием, появившемся в Python 3.6:

```python
name = 'Alexey'
age = 44
print(f'{name} is {age} years old')
# Alexey is 44 years old
```
Экранирование в таких строках работает.

#### Экранирование символов

* Как в C: \a, \b, \f, \n, \t, \v
* Нулевой байт: \0 (Python не воспринимает его как конец строки!)
* Для символов, помещающихся в нижние 8 бит: \x20 (шестнадцатеричное представление) и \o20 (восмеричное)
* Для полноценных Unicode-символов: \u1234 (16-битный символ) и \U00012345 (32-битный символ)
* \N{id}, где id - индентификатор символа Unicode. Посмотреть идентификатор можно здесь: https://unicode-table.com. Пример:

```python
print('\N{Middle dot}')
# ·
```

#### Docstrings или doc-строки

Для методов и классов (на самом деле, кавычки и префиксы у литералов могут быть любые, подходящие по ситуации):

```python
def my_cool_function(x, y):
    r"""
    Складывает два числа.
    
    :param x: Первое слагаемое
    :param y: Второе слагаемое
    :return: Сумма 
    """
    
    return x + y
```

Начальные и конечные пробелы в doc-строках автоматически обрезаются. 
    
Для переменных это дело не работает :(

#### Новое форматирование

```python
a = 5
b = 10
print(f'Пять плюс десять равняется {a + b}, а не {2 * (a + b)}!')
# 'Пять плюс десять равняется 15, а не 30!
```
